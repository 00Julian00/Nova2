"""
Description: Holds all data related to context data.
"""

from typing import Generator
from datetime import datetime
from queue import Queue
from enum import Enum
from threading import Thread
import time
from dataclasses import dataclass

from Nova2.app.llm_data import Conversation, Message

class ContextSourceBase:
    @classmethod
    def get_all_sources(cls) -> list[type]:
        return cls.__subclasses__()

@dataclass
class ContextSource_Voice(ContextSourceBase):
    speaker: str

class ContextSource_User(ContextSourceBase):
    pass

class ContextSource_Assistant(ContextSourceBase):
    pass

@dataclass
class ContextSource_ToolResponse(ContextSourceBase):
    name: str
    id: str

class ContextSource_System(ContextSourceBase):
    pass

@dataclass
class ContextDatapoint:
    """
    This class holds a singular datapoint in the context.
    """
    source: ContextSourceBase
    content: str
    timestamp=datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
    
    def to_dict(self) -> dict:
        """
        Returns the contents formatted to a dictionary so it can be serialized to json.
        """
        # Check if the source contains metadata
        if bool(self.source.__dict__):
            return {
                "source": {
                    "type": self.source.__class__.__name__,
                    "metadata": self.source.__dict__
                },
                "content": self.content,
                "timestamp": self.timestamp
            }
        else:
            return {
                "source": {
                    "type": self.source.__class__.__name__
                },
                "content": self.content,
                "timestamp": self.timestamp
            }

@dataclass
class Context:
    """
    This class stores context which is a list of datapoints all with source, content and timestamp.
    """
    data_points: list[ContextDatapoint]

    def to_conversation(self) -> Conversation:
        """
        Get the context as type Conversation that can be parsed to the LLM.
        """
        messages = []

        # Thank you python that I am not allowed to use a match-case here.
        for datapoint in self.data_points:
            if type(datapoint.source) == ContextSource_Assistant:
                messages.append(
                    Message(
                        author="assistant",
                        content=datapoint.content # Assistant message does not need a timestamp
                ))
            elif type(datapoint.source) == ContextSource_Voice:
                messages.append(
                    Message(
                        author="user",
                        content=f"{datapoint.source.speaker} ({datapoint.timestamp}): {datapoint.content}"
                ))
            elif type(datapoint.source) == ContextSource_User:
                messages.append(
                    Message(
                        author="user",
                        content=f"({datapoint.timestamp}) {datapoint.content}"
                ))
            elif type(datapoint.source) == ContextSource_ToolResponse:
                messages.append(
                    Message(
                        author="tool",
                        name=datapoint.source.name,
                        tool_call_id=datapoint.source.id,
                        content=f"({datapoint.timestamp}) {datapoint.content}"
                    )
                )
            elif type(datapoint.source) == ContextSource_System:
                messages.append(
                    Message(
                        author="system",
                        content=f"{datapoint.timestamp}: {datapoint.content}"
                    )
                )
            else:
                raise Exception(f"Could not format context to conversation. Unknown source: {type(datapoint.source)}")

        return Conversation(messages)

@dataclass
class ContextGenerator:
    """
    Holds the data generator produced by a context generator. Yields ContextDatapoint.
    """
    _generator: Generator

    def data(self):
        """
        Begins to yield the data generated by the generator.
        """
        for datapoint in self._generator:
            yield datapoint

class ContextGeneratorList:
    def __init__(self) -> None:
        """
        Manages a dynamic thread-safe list of context sources that can be itterated through.
        """
        self._index = 0
        self._sources = []

        self._command_queue = Queue()

        self._worker_thread = Thread(target=self._worker, daemon=True)
        self._worker_thread.start()

    def add(self, context_source: ContextGenerator) -> None:
        self._command_queue.put((ListCommands.ADD, context_source))

    def remove(self, context_source: ContextGenerator) -> None:
        self._command_queue.put((ListCommands.REMOVE, context_source))

    def get_next(self) -> ContextDatapoint:
        result = Queue()
        self._command_queue.put((ListCommands.GET_NEXT, result))
        return result.get()
    
    def _worker(self):
        while True:
            command = self._command_queue.get()

            match command[0]:
                case ListCommands.ADD:
                    self._sources.append(command[1].data())
                case ListCommands.REMOVE:
                    index = self._sources.index(command[1])

                    self._sources.remove(command[1])

                    if index < self._index:
                        self._index -= 1
                case ListCommands.GET_NEXT:
                    result = None

                    while not result:
                        if len(self._sources) == 0:
                            break

                        try:
                            result = next(self._sources[self._index])
                        except StopIteration:
                            self._sources.remove(self._sources[self._index])
                    
                    command[1].put(result) # Return the next item from the context source and then move onto the next source

                    self._index += 1

            # Prevent over and underflow
            if self._index < 0:
                self._index = len(self._sources) - 1
            elif self._index >= len(self._sources):
                self._index = 0

            time.sleep(0.1)

class ListCommands(Enum):
    ADD = "add"
    REMOVE = "remove"
    GET_NEXT = "get_next"